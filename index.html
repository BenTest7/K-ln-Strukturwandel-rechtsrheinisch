<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Strukturwandel Köln – Deutz & Mülheim (reale Grenzen, SW-High-Contrast, Zoom-Details)</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
<style>
  html, body { height:100%; margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
  header { padding:10px 12px; border-bottom:1px solid #ddd; background:#fff; }
  header h1 { font-size:16px; margin:0 0 6px; }
  header p { margin:0; font-size:12px; color:#444; line-height:1.25; }
  #map { height: calc(100% - 82px); width:100%; }

  /* SW + sehr deutlich (Straßen/Schrift besser sichtbar) */
  .leaflet-tile {
    filter: grayscale(100%) contrast(220%) brightness(92%);
  }

  .roleBtn{
    display:block; width:100%;
    margin:6px 0; padding:10px 12px;
    font-size:14px; border-radius:10px;
    border:1px solid #ddd; background:#f7f7f7;
  }
  .roleBtn:active { transform: translateY(1px); }

  .statusBox{
    background: rgba(255,255,255,.95);
    border: 1px solid #ddd;
    border-radius: 12px;
    padding: 8px 10px;
    box-shadow: 0 10px 26px rgba(0,0,0,.12);
    font-size: 12px;
    line-height: 1.25;
  }

  /* Dauerhafte Labels */
  .districtLabel{
    background: rgba(255,255,255,0.82);
    border: 1px solid rgba(0,0,0,0.22);
    border-radius: 999px;
    padding: 2px 8px;
    color:#111;
    font-weight: 900;
    font-size: 12px;
    box-shadow: 0 6px 18px rgba(0,0,0,.14);
    white-space: nowrap;
  }
  .poiLabel{
    background: rgba(255,255,255,0.90);
    border: 1px solid rgba(0,0,0,0.28);
    border-radius: 10px;
    padding: 2px 6px;
    color:#111;
    font-weight: 900;
    font-size: 11px;
    box-shadow: 0 6px 18px rgba(0,0,0,.14);
    white-space: nowrap;
  }
</style>
</head>
<body>
<header>
  <h1>Strukturwandel Köln – Rollenkarte (Deutz & Mülheim)</h1>
  <p>
    Basiskarte: <b>Straßenkarte Schwarz/Weiß (hoher Kontrast)</b>. Klick auf eine Fläche → Rolle wählen: Industrie <b>(blau)</b>, Start-ups <b>(gelb)</b>, Wohnen <b>(rot)</b>, Freizeit/Kultur <b>(grün)</b>.
    <br>Nur: <b>Deutz</b> + <b>Mülheim-Stadtviertel</b> + Spezialbezirke (Lanxess Arena, koelnmesse, Bhf Deutz, Carlswerk). Namen sind dauerhaft sichtbar.
  </p>
</header>

<div id="map" aria-label="Interaktive Karte"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
/* Geoportal Stadt Köln / ArcGIS REST
   - Stadtteile:   Basiskarten/kgg/MapServer/3
   - Stadtviertel: Basiskarten/kgg/MapServer/1
*/
const map = L.map('map', { zoomControl: true }).setView([50.948, 7.008], 13);

// Panes: verhindert Farbmischung bei Spezialbezirken (liegen oben, mit voller Deckkraft)
map.createPane('paneST');      map.getPane('paneST').style.zIndex = 350;
map.createPane('paneSV');      map.getPane('paneSV').style.zIndex = 360;
map.createPane('paneMICRO');   map.getPane('paneMICRO').style.zIndex = 370;
map.createPane('panePOI');     map.getPane('panePOI').style.zIndex = 420;

// OSM Straßen als Standard
const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 19, attribution: '© OpenStreetMap-Mitwirkende'
}).addTo(map);

// Alternative: Carto Light
const carto = L.tileLayer('https://cartodb-basemaps-{s}.global.ssl.fastly.net/light_all/{z}/{x}/{y}.png', {
  subdomains:'abcd', maxZoom: 20,
  attribution: 'Map tiles by Carto (CC BY 3.0). Data © OpenStreetMap contributors (ODbL).'
});
L.control.layers({"OSM Straßen (SW Hi-Contrast)": osm, "Carto Light (SW)": carto}, null, {collapsed:true}).addTo(map);

// Rollen / Farben
const roleColors = {
  "Industrie": "blue",
  "Start-ups": "yellow",
  "Wohnen": "red",
  "Freizeit/Kultur": "green"
};

const STORAGE_KEY = "koeln_roles_deutz_muelheim_v5";
let saved = {};
try { saved = JSON.parse(localStorage.getItem(STORAGE_KEY) || "{}"); } catch(e) { saved = {}; }
function save() { localStorage.setItem(STORAGE_KEY, JSON.stringify(saved)); }

function popupHTML(key, name){
  return `
    <b>${name}</b><br>
    <button class="roleBtn" onclick="setRole('${key}','Industrie')">Industrie (blau)</button>
    <button class="roleBtn" onclick="setRole('${key}','Start-ups')">Start-ups (gelb)</button>
    <button class="roleBtn" onclick="setRole('${key}','Wohnen')">Wohnen (rot)</button>
    <button class="roleBtn" onclick="setRole('${key}','Freizeit/Kultur')">Freizeit/Kultur (grün)</button>
    <button class="roleBtn" onclick="clearRole('${key}')">Keine Zuordnung</button>
  `;
}

const layerByKey = {};
const microGroup = L.layerGroup([], {pane:'paneMICRO'}).addTo(map);
let schanzenTargets = []; // features to subdivide at high zoom

window.setRole = function(key, role){
  saved[key] = role; save();
  const lyr = layerByKey[key];
  if(lyr && lyr.setStyle) lyr.setStyle(styleForKey(key, lyr.__kind));
  if(lyr) lyr.closePopup();
};
window.clearRole = function(key){
  delete saved[key]; save();
  const lyr = layerByKey[key];
  if(lyr && lyr.setStyle) lyr.setStyle(styleForKey(key, lyr.__kind));
  if(lyr) lyr.closePopup();
};

function styleForKey(key, kind){
  const role = saved[key];
  const fillColor = (role && roleColors[role]) ? roleColors[role] : "white";
  const hasRole = !!(role && roleColors[role]);

  // Wichtig: Spezialbezirke sollen NICHT durchscheinen → bei Rolle volle Deckkraft
  if(kind === "POI"){
    return {
      pane:'panePOI',
      color:"#111",
      weight: 5,
      fillColor,
      fillOpacity: hasRole ? 1.0 : 0.20
    };
  }

  // Polygone (Deutz/Mülheim)
  const baseOpacity = (kind === "SV") ? 0.14 : 0.10;
  return {
    color:"#111",
    weight: 3,
    fillColor,
    fillOpacity: hasRole ? 0.55 : baseOpacity
  };
}

// Status
const statusCtl = L.control({position:'topleft'});
let statusEl;
statusCtl.onAdd = function(){
  statusEl = L.DomUtil.create('div', 'statusBox');
  statusEl.innerHTML = "<b>Status:</b> Lade Grenzen…";
  L.DomEvent.disableClickPropagation(statusEl);
  return statusEl;
};
statusCtl.addTo(map);
function setStatus(html){ if(statusEl) statusEl.innerHTML = html; }

// ArcGIS fetch
async function arcgisQuery(layerId, params){
  const base = `https://geoportal.stadt-koeln.de/arcgis/rest/services/Basiskarten/kgg/MapServer/${layerId}/query`;
  const p = new URLSearchParams(params);

  // try geojson
  let url = base + "?" + p.toString() + "&f=geojson";
  try{
    const r = await fetch(url);
    if(r.ok){
      const gj = await r.json();
      if(gj && gj.type === "FeatureCollection") return gj;
    }
  } catch(e){}

  // fallback pjson
  url = base + "?" + p.toString() + "&f=pjson";
  const r2 = await fetch(url);
  if(!r2.ok) throw new Error("ArcGIS query failed: " + r2.status);
  const data = await r2.json();
  return esriToGeoJSON(data);
}

function esriToGeoJSON(esri){
  const feats = (esri.features || []).map((f) => {
    const props = f.attributes || {};
    const g = f.geometry || {};
    if(g.rings){
      return {
        type:"Feature",
        properties: props,
        geometry: { type:"Polygon", coordinates: g.rings.map(r => r.map(pt => [pt[0], pt[1]])) }
      };
    }
    return null;
  }).filter(Boolean);
  return { type:"FeatureCollection", features: feats };
}

function pickName(props, candidates){
  for(const c of candidates){
    if(props && props[c] != null && String(props[c]).trim() !== "") return String(props[c]).trim();
  }
  const keys = props ? Object.keys(props) : [];
  for(const cand of candidates){
    const k = keys.find(x => x.toLowerCase() === cand.toLowerCase());
    if(k && props[k] != null) return String(props[k]).trim();
  }
  return null;
}

// centroid from first ring average
function approxCentroidLonLat(feature){
  try{
    const ring = feature.geometry.coordinates[0];
    let sx=0, sy=0, n=0;
    for(const pt of ring){ sx += pt[0]; sy += pt[1]; n++; }
    return {lon: sx/n, lat: sy/n};
  } catch(e){ return null; }
}

// Point-in-polygon (ray casting), polygon is [ [lon,lat], ... ]
function pointInPoly(pt, poly){
  const x = pt[0], y = pt[1];
  let inside = false;
  for(let i=0, j=poly.length-1; i<poly.length; j=i++){
    const xi = poly[i][0], yi = poly[i][1];
    const xj = poly[j][0], yj = poly[j][1];
    const intersect = ((yi>y)!==(yj>y)) && (x < (xj-xi)*(y-yi)/(yj-yi+1e-12)+xi);
    if(intersect) inside = !inside;
  }
  return inside;
}

// ROUTE envelope (enger): Deutz bis Mülheim
const env = { xmin: 6.975, ymin: 50.932, xmax: 7.035, ymax: 50.972 };
const RIGHT_BANK_LON_MIN = 6.975;

let stLayer=null, svLayer=null;

function addPermanentLabel(layer, name, className){
  layer.bindTooltip(name, {
    permanent: true, direction: 'center',
    className: className, opacity: 1.0
  });
}

async function loadBoundaries(){
  setStatus("<b>Status:</b> Lade Deutz & Mülheim…");

  const qCommon = {
    where: "1=1",
    outFields: "*",
    returnGeometry: "true",
    outSR: "4326",
    inSR: "4326",
    geometry: `${env.xmin},${env.ymin},${env.xmax},${env.ymax}`,
    geometryType: "esriGeometryEnvelope",
    spatialRel: "esriSpatialRelIntersects",
    resultRecordCount: "5000"
  };

  const st = await arcgisQuery(3, qCommon);
  const sv = await arcgisQuery(1, qCommon);

  // Filter rechtsrheinisch + nur Deutz/Mülheim + remove "Siedlung*"
  st.features = st.features.filter(f => {
    const c = approxCentroidLonLat(f);
    if(!(c && c.lon >= RIGHT_BANK_LON_MIN)) return false;
    const nm = (pickName(f.properties, ["STADTTEIL","NAME","Name","stadtteil"]) || "").trim();
    if(/^Siedlung/i.test(nm)) return false;
    return /deutz/i.test(nm) || /mülheim/i.test(nm) || /muelheim/i.test(nm);
  });

  sv.features = sv.features.filter(f => {
    const c = approxCentroidLonLat(f);
    if(!(c && c.lon >= RIGHT_BANK_LON_MIN)) return false;
    const nm = (pickName(f.properties, ["STADTVIERTEL","NAME","Name","stadtviertel","STV","BEZEICHNUNG"]) || "").trim();
    if(/^Siedlung/i.test(nm)) return false;

    const stnm = (pickName(f.properties, ["STADTTEIL","STADTTEILNAME","stadtteil"]) || "").trim();
    const bznm = (pickName(f.properties, ["STADTBEZIRK","BEZIRK","stadtbezirk"]) || "").trim();
    const tag = (nm + " " + stnm + " " + bznm).toLowerCase();

    // nur Mülheim Stadtviertel
    return tag.includes("mülheim") || tag.includes("muelheim");
  });

  // Reset micro
  schanzenTargets = [];
  microGroup.clearLayers();

  if(stLayer) map.removeLayer(stLayer);
  if(svLayer) map.removeLayer(svLayer);

  // Stadtteile
  st.features.forEach(ft => {
    const nm = (pickName(ft.properties, ["STADTTEIL","NAME","Name","stadtteil"]) || "Ort").trim();
    ft.properties.__name = nm;
    ft.properties.__key  = "ST:" + nm;
    ft.properties.__kind = "ST";
  });

  stLayer = L.geoJSON(st, {
    pane:'paneST',
    style: (feature) => styleForKey(feature.properties.__key, "ST"),
    onEachFeature: (feature, layer) => {
      const key = feature.properties.__key;
      const name = feature.properties.__name;
      layer.__kind = "ST";
      layerByKey[key] = layer;
      layer.bindPopup(popupHTML(key, name), {maxWidth: 300});
      layer.on('click', () => layer.openPopup());
      addPermanentLabel(layer, name, "districtLabel");
    }
  }).addTo(map);

  // Stadtviertel (Mülheim)
  sv.features.forEach(ft => {
    const nm = (pickName(ft.properties, ["STADTVIERTEL","NAME","Name","stadtviertel","STV","BEZEICHNUNG"]) || "Ort").trim();
    ft.properties.__name = nm;
    ft.properties.__key  = "SV:" + nm;
    ft.properties.__kind = "SV";

    // merken für Zoom-Subdivisions: Schanzenstraße (auch "GE Schanzenstraße")
    if(/schanzenstr/i.test(nm) || /GE\s*schanzen/i.test(nm)){
      schanzenTargets.push(ft);
    }
  });

  svLayer = L.geoJSON(sv, {
    pane:'paneSV',
    style: (feature) => styleForKey(feature.properties.__key, "SV"),
    onEachFeature: (feature, layer) => {
      const key = feature.properties.__key;
      const name = feature.properties.__name;
      layer.__kind = "SV";
      layerByKey[key] = layer;
      layer.bindPopup(popupHTML(key, name), {maxWidth: 300});
      layer.on('click', () => layer.openPopup());
      addPermanentLabel(layer, name, "districtLabel");
    }
  }).addTo(map);

  // Spezialbezirke (oben, keine Farbmischung)
  addPOI("Lanxess Arena", [50.938338, 6.982951], 180);
  addPOI("koelnmesse",    [50.944600, 6.981800], 230);
  addPOI("Bhf Deutz",     [50.940830, 6.975000], 190);

  // Carlswerk korrigiert (Schanzenstraße 6-20; Nähe) – deutlich weiter nördlich als vorher
  addPOI("Carlswerk",     [50.966074, 7.015056], 190);

  // View
  map.fitBounds(L.latLngBounds([[env.ymin, env.xmin],[env.ymax, env.xmax]]), {padding:[30,30]});

  setStatus("<b>Status:</b> Fertig. Zoome rein (≥16) für kleinteiligere Teilflächen in Schanzenstraße.");
  updateMicroTiles(); // initial
}

function addPOI(name, latlng, radius){
  const key = "POI:" + name;
  const circle = L.circle(latlng, { radius, ...styleForKey(key, "POI"), pane:'panePOI' });
  circle.__kind = "POI";
  layerByKey[key] = circle;
  circle.bindPopup(popupHTML(key, name), {maxWidth: 280});
  circle.on('click', () => circle.openPopup());
  circle.addTo(map);
  circle.bindTooltip(name, { permanent:true, direction:'top', offset:[0,-8], className:'poiLabel', opacity:1.0 });
}

// Zoom-abhängige kleinteiligere Teilflächen (nur Schanzenstraße / GE Schanzenstraße)
// Hinweis: Diese Teilflächen sind eine Zoom-Hilfe (kleinteiliger), basieren auf der Originalfläche (nur innerhalb) – ohne zusätzliche Datensätze.
function updateMicroTiles(){
  microGroup.clearLayers();
  const z = map.getZoom();
  if(z < 16) return;

  // Erzeuge kleine "Mikroflächen" innerhalb der Schanzen-Polygone
  schanzenTargets.forEach(ft => {
    const name = ft.properties.__name || "Schanzenstraße";
    const keyBase = "MICRO:" + name + ":";

    // bbox aus erster Ring
    const ring = ft.geometry.coordinates[0];
    let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
    ring.forEach(([x,y]) => { minX=Math.min(minX,x); minY=Math.min(minY,y); maxX=Math.max(maxX,x); maxY=Math.max(maxY,y); });

    // Aufteilung je nach Zoom: 4x3 (z=16) oder 5x4 (z>=17)
    const nx = (z >= 17) ? 5 : 4;
    const ny = (z >= 17) ? 4 : 3;

    const dx = (maxX-minX)/nx;
    const dy = (maxY-minY)/ny;

    for(let ix=0; ix<nx; ix++){
      for(let iy=0; iy<ny; iy++){
        const cx = minX + (ix+0.5)*dx;
        const cy = minY + (iy+0.5)*dy;
        // nur wenn Mittelpunkt in Polygon
        if(!pointInPoly([cx,cy], ring)) continue;

        const microName = `${name} – Teil ${ix+1}.${iy+1}`;
        const microKey = keyBase + (ix+1) + "." + (iy+1);

        const rect = L.polygon([
          [cy-dy/2, cx-dx/2],
          [cy-dy/2, cx+dx/2],
          [cy+dy/2, cx+dx/2],
          [cy+dy/2, cx-dx/2]
        ], {
          pane:'paneMICRO',
          ...styleForKey(microKey, "SV"),
          weight: 2
        });

        rect.__kind = "SV";
        layerByKey[microKey] = rect;
        rect.bindPopup(popupHTML(microKey, microName), {maxWidth: 300});
        rect.on('click', () => rect.openPopup());
        microGroup.addLayer(rect);
      }
    }
  });
}

// Tools
const tools = L.control({position:'topright'});
tools.onAdd = function() {
  const div = L.DomUtil.create('div', 'statusBox');
  div.style.minWidth = '200px';
  div.innerHTML = `
    <b>Tools</b><br>
    <button id="btnReload" style="width:100%; margin-top:6px; padding:8px 10px; border:1px solid #ddd; border-radius:10px; background:#fff; font-size:13px; cursor:pointer;">Grenzen neu laden</button>
    <button id="btnReset" style="width:100%; margin-top:6px; padding:8px 10px; border:1px solid #ddd; border-radius:10px; background:#fff; font-size:13px; cursor:pointer;">Farben zurücksetzen</button>
    <button id="btnExport" style="width:100%; margin-top:6px; padding:8px 10px; border:1px solid #ddd; border-radius:10px; background:#fff; font-size:13px; cursor:pointer;">Export (Text)</button>
    <div style="margin-top:8px; font-size:11px; color:#666; line-height:1.25;">
      Zoom ≥16: Schanzenstraße wird kleinteiliger.
    </div>
  `;
  L.DomEvent.disableClickPropagation(div);
  return div;
};
tools.addTo(map);

function resetColors(){
  saved = {}; save();
  Object.keys(layerByKey).forEach(key => {
    const lyr = layerByKey[key];
    if(lyr && lyr.setStyle) lyr.setStyle(styleForKey(key, lyr.__kind || "SV"));
  });
}
function exportText(){
  const keys = Object.keys(layerByKey).sort();
  const out = keys.map(k => ({gebiet: k.replace(/^ST:/,"").replace(/^SV:/,"").replace(/^POI:/,"").replace(/^MICRO:/,""), rolle: saved[k] || ""}));
  prompt("Kopiere den Export-Text (Copy):", JSON.stringify(out, null, 2));
}

document.addEventListener('click', (e) => {
  if(e.target && e.target.id === 'btnReload') loadBoundaries().catch(err => setStatus("<b>Status:</b> Fehler: " + err.message));
  if(e.target && e.target.id === 'btnReset') resetColors();
  if(e.target && e.target.id === 'btnExport') exportText();
});

map.on('zoomend', updateMicroTiles);

loadBoundaries().catch(err => {
  console.error(err);
  setStatus("<b>Status:</b> Fehler beim Laden der Grenzen.<br><span style='color:#b00'>"+ err.message +"</span>");
});
</script>
</body>
</html>
