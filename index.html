<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Strukturwandel Köln – Deutz & Mülheim (reale Grenzen, SW-High-Contrast, Labels)</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
<style>
  html, body { height:100%; margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
  header { padding:10px 12px; border-bottom:1px solid #ddd; background:#fff; }
  header h1 { font-size:16px; margin:0 0 6px; }
  header p { margin:0; font-size:12px; color:#444; line-height:1.25; }
  #map { height: calc(100% - 82px); width:100%; }

  /* SW + deutlich (Kontrast hoch, Linien "knackig") */
  .leaflet-tile {
    filter: grayscale(100%) contrast(170%) brightness(118%);
  }

  /* Popup Buttons */
  .roleBtn{
    display:block; width:100%;
    margin:6px 0; padding:10px 12px;
    font-size:14px; border-radius:10px;
    border:1px solid #ddd; background:#f7f7f7;
  }
  .roleBtn:active { transform: translateY(1px); }

  /* Status/Tools Box */
  .statusBox{
    background: rgba(255,255,255,.94);
    border: 1px solid #ddd;
    border-radius: 12px;
    padding: 8px 10px;
    box-shadow: 0 10px 26px rgba(0,0,0,.10);
    font-size: 12px;
    line-height: 1.25;
  }

  /* Dauerhafte Labels */
  .districtLabel{
    background: rgba(255,255,255,0.78);
    border: 1px solid rgba(0,0,0,0.20);
    border-radius: 999px;
    padding: 2px 8px;
    color:#111;
    font-weight: 800;
    font-size: 12px;
    box-shadow: 0 6px 18px rgba(0,0,0,.12);
    white-space: nowrap;
  }
  .poiLabel{
    background: rgba(255,255,255,0.85);
    border: 1px solid rgba(0,0,0,0.25);
    border-radius: 10px;
    padding: 2px 6px;
    color:#111;
    font-weight: 800;
    font-size: 11px;
    box-shadow: 0 6px 18px rgba(0,0,0,.12);
    white-space: nowrap;
  }
</style>
</head>
<body>
<header>
  <h1>Strukturwandel Köln – Rollenkarte (Deutz & Mülheim)</h1>
  <p>
    Basiskarte: <b>Straßenkarte Schwarz/Weiß (hoher Kontrast)</b>. Klick auf eine Fläche → Rolle wählen: Industrie <b>(blau)</b>, Start-ups <b>(gelb)</b>, Wohnen <b>(rot)</b>, Freizeit/Kultur <b>(grün)</b>.
    <br>Nur die Gebiete der Route: <b>Deutz</b> + <b>Stadtviertel in Mülheim</b> + Spezialbezirke (Lanxess Arena, koelnmesse, Bhf Deutz, Carlswerk). Labels sind dauerhaft sichtbar.
  </p>
</header>

<div id="map" aria-label="Interaktive Karte"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
/* Geoportal Stadt Köln / ArcGIS REST
   - Stadtteile:   Basiskarten/kgg/MapServer/3
   - Stadtviertel: Basiskarten/kgg/MapServer/1
*/
const map = L.map('map', { zoomControl: true }).setView([50.948, 7.008], 13);

// OSM Straßen als Standard (Kontrast via CSS)
const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 19, attribution: '© OpenStreetMap-Mitwirkende'
}).addTo(map);

// Alternative: Carto Light (ebenfalls SW via CSS)
const carto = L.tileLayer('https://cartodb-basemaps-{s}.global.ssl.fastly.net/light_all/{z}/{x}/{y}.png', {
  subdomains:'abcd', maxZoom: 20,
  attribution: 'Map tiles by Carto (CC BY 3.0). Data © OpenStreetMap contributors (ODbL).'
});
L.control.layers({"OSM Straßen (SW Hi-Contrast)": osm, "Carto Light (SW)": carto}, null, {collapsed:true}).addTo(map);

// Rollen / Farben
const roleColors = {
  "Industrie": "blue",
  "Start-ups": "yellow",
  "Wohnen": "red",
  "Freizeit/Kultur": "green"
};

const STORAGE_KEY = "koeln_roles_deutz_muelheim_v4";
let saved = {};
try { saved = JSON.parse(localStorage.getItem(STORAGE_KEY) || "{}"); } catch(e) { saved = {}; }
function save() { localStorage.setItem(STORAGE_KEY, JSON.stringify(saved)); }

function popupHTML(key, name){
  return `
    <b>${name}</b><br>
    <button class="roleBtn" onclick="setRole('${key}','Industrie')">Industrie (blau)</button>
    <button class="roleBtn" onclick="setRole('${key}','Start-ups')">Start-ups (gelb)</button>
    <button class="roleBtn" onclick="setRole('${key}','Wohnen')">Wohnen (rot)</button>
    <button class="roleBtn" onclick="setRole('${key}','Freizeit/Kultur')">Freizeit/Kultur (grün)</button>
    <button class="roleBtn" onclick="clearRole('${key}')">Keine Zuordnung</button>
  `;
}

const layerByKey = {};

window.setRole = function(key, role){
  saved[key] = role; save();
  const lyr = layerByKey[key];
  if(lyr && lyr.setStyle) lyr.setStyle(styleForKey(key, lyr.__kind));
  if(lyr) lyr.closePopup();
};
window.clearRole = function(key){
  delete saved[key]; save();
  const lyr = layerByKey[key];
  if(lyr && lyr.setStyle) lyr.setStyle(styleForKey(key, lyr.__kind));
  if(lyr) lyr.closePopup();
};

function styleForKey(key, kind){
  const role = saved[key];
  const fillColor = (role && roleColors[role]) ? roleColors[role] : "white";
  const hasRole = !!(role && roleColors[role]);
  // Polygone: ohne Rolle transparent, mit Rolle kräftiger
  let baseOpacity = (kind === "SV") ? 0.14 : 0.10;
  if(kind === "POI") baseOpacity = 0.10;
  const fillOpacity = hasRole ? 0.58 : baseOpacity;
  const weight = (kind === "POI") ? 5 : 3; // dickere Umrisse für Orientierung
  return { color:"#111", weight, fillColor, fillOpacity };
}

// Status
const statusCtl = L.control({position:'topleft'});
let statusEl;
statusCtl.onAdd = function(){
  statusEl = L.DomUtil.create('div', 'statusBox');
  statusEl.innerHTML = "<b>Status:</b> Lade Grenzen…";
  L.DomEvent.disableClickPropagation(statusEl);
  return statusEl;
};
statusCtl.addTo(map);
function setStatus(html){ if(statusEl) statusEl.innerHTML = html; }

// ArcGIS fetch
async function arcgisQuery(layerId, params){
  const base = `https://geoportal.stadt-koeln.de/arcgis/rest/services/Basiskarten/kgg/MapServer/${layerId}/query`;
  const p = new URLSearchParams(params);

  // try geojson
  let url = base + "?" + p.toString() + "&f=geojson";
  try{
    const r = await fetch(url);
    if(r.ok){
      const gj = await r.json();
      if(gj && gj.type === "FeatureCollection") return gj;
    }
  } catch(e){}

  // fallback pjson
  url = base + "?" + p.toString() + "&f=pjson";
  const r2 = await fetch(url);
  if(!r2.ok) throw new Error("ArcGIS query failed: " + r2.status);
  const data = await r2.json();
  return esriToGeoJSON(data);
}

function esriToGeoJSON(esri){
  const feats = (esri.features || []).map((f) => {
    const props = f.attributes || {};
    const g = f.geometry || {};
    if(g.rings){
      return {
        type:"Feature",
        properties: props,
        geometry: { type:"Polygon", coordinates: g.rings.map(r => r.map(pt => [pt[0], pt[1]])) }
      };
    }
    return null;
  }).filter(Boolean);
  return { type:"FeatureCollection", features: feats };
}

function pickName(props, candidates){
  for(const c of candidates){
    if(props && props[c] != null && String(props[c]).trim() !== "") return String(props[c]).trim();
  }
  const keys = props ? Object.keys(props) : [];
  for(const cand of candidates){
    const k = keys.find(x => x.toLowerCase() === cand.toLowerCase());
    if(k && props[k] != null) return String(props[k]).trim();
  }
  return null;
}

// approximate centroid from first ring average
function approxCentroidLonLat(feature){
  try{
    const ring = feature.geometry.coordinates[0];
    let sx=0, sy=0, n=0;
    for(const pt of ring){ sx += pt[0]; sy += pt[1]; n++; }
    return {lon: sx/n, lat: sy/n};
  } catch(e){
    return null;
  }
}

// ROUTE envelope (enger): Deutz bis Mülheim (nicht weiter)
const env = {
  xmin: 6.975, ymin: 50.932,   // Deutz/Arena
  xmax: 7.035, ymax: 50.972    // Mülheim/Carlswerk
};
const RIGHT_BANK_LON_MIN = 6.975;

let stLayer=null, svLayer=null;

// Add permanent label helper
function addPermanentLabel(layer, name, className){
  layer.bindTooltip(name, {
    permanent: true,
    direction: 'center',
    className: className,
    opacity: 1.0
  });
}

async function loadBoundaries(){
  setStatus("<b>Status:</b> Lade Deutz & Mülheim…");

  const qCommon = {
    where: "1=1",
    outFields: "*",
    returnGeometry: "true",
    outSR: "4326",
    inSR: "4326",
    geometry: `${env.xmin},${env.ymin},${env.xmax},${env.ymax}`,
    geometryType: "esriGeometryEnvelope",
    spatialRel: "esriSpatialRelIntersects",
    resultRecordCount: "5000"
  };

  // Stadtteile (Kontext) – aber nur Deutz und Mülheim
  const st = await arcgisQuery(3, qCommon);
  // Stadtviertel – aber nur die, die zu Mülheim gehören
  const sv = await arcgisQuery(1, qCommon);

  // rechtsrheinisch + Name-Filter
  st.features = st.features.filter(f => {
    const c = approxCentroidLonLat(f);
    if(!(c && c.lon >= RIGHT_BANK_LON_MIN)) return false;
    const nm = pickName(f.properties, ["STADTTEIL","NAME","Name","stadtteil"]) || "";
    return /deutz/i.test(nm) || /mülheim/i.test(nm);
  });

  // Stadtviertel: nur Mülheim (über mehrere mögliche Attribute)
  sv.features = sv.features.filter(f => {
    const c = approxCentroidLonLat(f);
    if(!(c && c.lon >= RIGHT_BANK_LON_MIN)) return false;
    const nm = pickName(f.properties, ["STADTVIERTEL","NAME","Name","stadtviertel","STV","BEZEICHNUNG"]) || "";
    const stnm = pickName(f.properties, ["STADTTEIL","STADTTEILNAME","stadtteil"]) || "";
    const bznm = pickName(f.properties, ["STADTBEZIRK","BEZIRK","stadtbezirk"]) || "";
    const tag = (nm + " " + stnm + " " + bznm).toLowerCase();
    return tag.includes("mülheim") || tag.includes("muelheim");
  });

  if(stLayer) map.removeLayer(stLayer);
  if(svLayer) map.removeLayer(svLayer);

  // Stadtteile: Deutz und Mülheim
  st.features.forEach(ft => {
    const nm = pickName(ft.properties, ["STADTTEIL","NAME","Name","stadtteil"]) || "Ort";
    ft.properties.__name = nm;
    ft.properties.__key  = "ST:" + nm;
    ft.properties.__kind = "ST";
  });

  stLayer = L.geoJSON(st, {
    style: (feature) => styleForKey(feature.properties.__key, "ST"),
    onEachFeature: (feature, layer) => {
      const key = feature.properties.__key;
      const name = feature.properties.__name;
      layer.__kind = "ST";
      layerByKey[key] = layer;
      layer.bindPopup(popupHTML(key, name), {maxWidth: 300});
      layer.on('click', () => layer.openPopup());
      addPermanentLabel(layer, name, "districtLabel");
    }
  }).addTo(map);

  // Stadtviertel: nur Mülheim-Teilflächen
  sv.features.forEach(ft => {
    const nm = pickName(ft.properties, ["STADTVIERTEL","NAME","Name","stadtviertel","STV","BEZEICHNUNG"]) || "Ort";
    ft.properties.__name = nm;
    ft.properties.__key  = "SV:" + nm;
    ft.properties.__kind = "SV";
  });

  svLayer = L.geoJSON(sv, {
    style: (feature) => styleForKey(feature.properties.__key, "SV"),
    onEachFeature: (feature, layer) => {
      const key = feature.properties.__key;
      const name = feature.properties.__name;
      layer.__kind = "SV";
      layerByKey[key] = layer;
      layer.bindPopup(popupHTML(key, name), {maxWidth: 300});
      layer.on('click', () => layer.openPopup());
      addPermanentLabel(layer, name, "districtLabel");
    }
  }).addTo(map);

  // Spezialbezirke (Kreise als eigene Flächen)
  addPOI("Lanxess Arena", [50.9386, 6.9822], 180);
  addPOI("koelnmesse",    [50.9446, 6.9836], 220);
  addPOI("Bhf Deutz",     [50.9409, 6.9827], 170);
  addPOI("Carlswerk",     [50.9546, 7.0149], 180);

  // View: enger und trotzdem gut orientierbar
  const bounds = L.latLngBounds([[env.ymin, env.xmin],[env.ymax, env.xmax]]);
  map.fitBounds(bounds, {padding:[30,30]});

  setStatus("<b>Status:</b> Fertig. (Deutz + Mülheim-Teilflächen + Spezialbezirke)");
}

function addPOI(name, latlng, radius){
  const key = "POI:" + name;
  const circle = L.circle(latlng, { radius, ...styleForKey(key, "POI") });
  circle.__kind = "POI";
  layerByKey[key] = circle;
  circle.bindPopup(popupHTML(key, name), {maxWidth: 280});
  circle.on('click', () => circle.openPopup());
  circle.addTo(map);
  // dauerhafter POI-Label (leicht versetzt)
  circle.bindTooltip(name, {
    permanent: true,
    direction: 'top',
    offset: [0,-8],
    className: 'poiLabel',
    opacity: 1.0
  });
}

// Tools
const tools = L.control({position:'topright'});
tools.onAdd = function() {
  const div = L.DomUtil.create('div', 'statusBox');
  div.style.minWidth = '190px';
  div.innerHTML = `
    <b>Tools</b><br>
    <button id="btnReload" style="width:100%; margin-top:6px; padding:8px 10px; border:1px solid #ddd; border-radius:10px; background:#fff; font-size:13px; cursor:pointer;">Grenzen neu laden</button>
    <button id="btnReset" style="width:100%; margin-top:6px; padding:8px 10px; border:1px solid #ddd; border-radius:10px; background:#fff; font-size:13px; cursor:pointer;">Farben zurücksetzen</button>
    <button id="btnExport" style="width:100%; margin-top:6px; padding:8px 10px; border:1px solid #ddd; border-radius:10px; background:#fff; font-size:13px; cursor:pointer;">Export (Text)</button>
  `;
  L.DomEvent.disableClickPropagation(div);
  return div;
};
tools.addTo(map);

function resetColors(){
  saved = {}; save();
  Object.keys(layerByKey).forEach(key => {
    const lyr = layerByKey[key];
    if(lyr.setStyle) lyr.setStyle(styleForKey(key, lyr.__kind || "ST"));
  });
}
function exportText(){
  const keys = Object.keys(layerByKey).sort();
  const out = keys.map(k => ({gebiet: k.replace(/^ST:/,"").replace(/^SV:/,"").replace(/^POI:/,""), rolle: saved[k] || ""}));
  prompt("Kopiere den Export-Text (Copy):", JSON.stringify(out, null, 2));
}

document.addEventListener('click', (e) => {
  if(e.target && e.target.id === 'btnReload') loadBoundaries().catch(err => setStatus("<b>Status:</b> Fehler: " + err.message));
  if(e.target && e.target.id === 'btnReset') resetColors();
  if(e.target && e.target.id === 'btnExport') exportText();
});

loadBoundaries().catch(err => {
  console.error(err);
  setStatus("<b>Status:</b> Fehler beim Laden der Grenzen.<br><span style='color:#b00'>"+ err.message +"</span>");
});
</script>
</body>
</html>
