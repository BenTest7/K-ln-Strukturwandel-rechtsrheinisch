<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Strukturwandel Köln – Rollenkarte (reale Grenzen, rechtsrheinisch, SW-Basemap)</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
<style>
  html, body { height:100%; margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
  header { padding:10px 12px; border-bottom:1px solid #ddd; background:#fff; }
  header h1 { font-size:16px; margin:0 0 6px; }
  header p { margin:0; font-size:12px; color:#444; line-height:1.25; }
  #map { height: calc(100% - 82px); width:100%; }

  /* Schwarz/Weiß-Look für Kacheln */
  .leaflet-tile { filter: grayscale(100%) contrast(120%) brightness(108%); }

  /* Popup Buttons */
  .roleBtn{
    display:block; width:100%;
    margin:6px 0; padding:10px 12px;
    font-size:14px; border-radius:10px;
    border:1px solid #ddd; background:#f7f7f7;
  }
  .roleBtn:active { transform: translateY(1px); }

  /* kleines Statusfeld */
  .statusBox{
    background: rgba(255,255,255,.92);
    border: 1px solid #ddd;
    border-radius: 12px;
    padding: 8px 10px;
    box-shadow: 0 10px 26px rgba(0,0,0,.08);
    font-size: 12px;
    line-height: 1.25;
  }
</style>
</head>
<body>
<header>
  <h1>Strukturwandel Köln (rechtsrheinisch) – Rollenkarte</h1>
  <p>
    Hintergrund: <b>Schwarz/Weiß</b>. Klick auf eine Fläche → Rolle wählen: Industrie <b>(blau)</b>, Start-ups <b>(gelb)</b>, Wohnen <b>(rot)</b>, Freizeit/Kultur <b>(grün)</b>.
    <br>Gesamtbereich: rechtsrheinisch (südlichster Rand: <b>Deutz</b>).
  </p>
</header>

<div id="map" aria-label="Interaktive Karte"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
/* =========================================================
   Datenquellen (Geoportal Stadt Köln / ArcGIS REST)
   - Stadtteile:   Basiskarten/kgg/MapServer/3
   - Stadtviertel: Basiskarten/kgg/MapServer/1
   ========================================================= */

const map = L.map('map', { zoomControl: true }).setView([50.947, 7.005], 14);

// Basemap (SW)
const carto = L.tileLayer('https://cartodb-basemaps-{s}.global.ssl.fastly.net/light_all/{z}/{x}/{y}.png', {
  subdomains: 'abcd', maxZoom: 20,
  attribution: 'Map tiles by Carto (CC BY 3.0). Data © OpenStreetMap contributors (ODbL).'
}).addTo(map);

const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 19, attribution: '© OpenStreetMap-Mitwirkende'
});

L.control.layers({"Carto (SW)": carto, "OSM (SW)": osm}, null, {collapsed:true}).addTo(map);

// Rollen / Farben
const roleColors = {
  "Industrie": "blue",
  "Start-ups": "yellow",
  "Wohnen": "red",
  "Freizeit/Kultur": "green"
};

const STORAGE_KEY = "koeln_roles_real_rr_v2";
let saved = {};
try { saved = JSON.parse(localStorage.getItem(STORAGE_KEY) || "{}"); } catch(e) { saved = {}; }
function save() { localStorage.setItem(STORAGE_KEY, JSON.stringify(saved)); }

function popupHTML(key, ortsname){
  // Popup soll nur den Ortsnamen zeigen (keine Hinweise/Interpretation)
  return `
    <b>${ortsname}</b><br>
    <button class="roleBtn" onclick="setRole('${key}','Industrie')">Industrie (blau)</button>
    <button class="roleBtn" onclick="setRole('${key}','Start-ups')">Start-ups (gelb)</button>
    <button class="roleBtn" onclick="setRole('${key}','Wohnen')">Wohnen (rot)</button>
    <button class="roleBtn" onclick="setRole('${key}','Freizeit/Kultur')">Freizeit/Kultur (grün)</button>
    <button class="roleBtn" onclick="clearRole('${key}')">Keine Zuordnung</button>
  `;
}

// Layer registry
const layerByKey = {};

window.setRole = function(key, role){
  saved[key] = role; save();
  if(layerByKey[key] && layerByKey[key].setStyle){
    layerByKey[key].setStyle(styleForKey(key, layerByKey[key].__kind));
  }
  if(layerByKey[key]) layerByKey[key].closePopup();
};
window.clearRole = function(key){
  delete saved[key]; save();
  if(layerByKey[key] && layerByKey[key].setStyle){
    layerByKey[key].setStyle(styleForKey(key, layerByKey[key].__kind));
  }
  if(layerByKey[key]) layerByKey[key].closePopup();
};

function styleForKey(key, kind){
  const role = saved[key];
  const fillColor = (role && roleColors[role]) ? roleColors[role] : "white";
  const hasRole = !!(role && roleColors[role]);
  // Stadtviertel etwas sichtbarer als Stadtteile, POIs am deutlichsten
  let baseOpacity = (kind === "SV") ? 0.18 : 0.10;
  if(kind === "POI") baseOpacity = 0.14;
  const fillOpacity = hasRole ? 0.60 : baseOpacity;
  const weight = (kind === "POI") ? 5 : (kind === "SV" ? 2.5 : 2);
  return { color:"#111", weight, fillColor, fillOpacity };
}

// Status
const statusCtl = L.control({position:'topleft'});
let statusEl;
statusCtl.onAdd = function(){
  statusEl = L.DomUtil.create('div', 'statusBox');
  statusEl.innerHTML = "<b>Status:</b> Lade Grenzen…";
  L.DomEvent.disableClickPropagation(statusEl);
  return statusEl;
};
statusCtl.addTo(map);
function setStatus(html){ if(statusEl) statusEl.innerHTML = html; }

/* =========================================================
   ArcGIS REST Fetch
   ========================================================= */
async function arcgisQuery(layerId, params){
  const base = `https://geoportal.stadt-koeln.de/arcgis/rest/services/Basiskarten/kgg/MapServer/${layerId}/query`;
  const p = new URLSearchParams(params);

  // Try geojson first
  let url = base + "?" + p.toString() + "&f=geojson";
  try{
    const r = await fetch(url);
    if(r.ok){
      const gj = await r.json();
      if(gj && gj.type === "FeatureCollection") return gj;
    }
  } catch(e){}

  // Fallback pjson
  url = base + "?" + p.toString() + "&f=pjson";
  const r2 = await fetch(url);
  if(!r2.ok) throw new Error("ArcGIS query failed: " + r2.status);
  const data = await r2.json();
  return esriToGeoJSON(data);
}

function esriToGeoJSON(esri){
  const feats = (esri.features || []).map((f) => {
    const props = f.attributes || {};
    const g = f.geometry || {};
    if(g.rings){
      return {
        type:"Feature",
        properties: props,
        geometry: { type:"Polygon", coordinates: g.rings.map(r => r.map(pt => [pt[0], pt[1]])) }
      };
    }
    return null;
  }).filter(Boolean);
  return { type:"FeatureCollection", features: feats };
}

function pickName(props, candidates){
  for(const c of candidates){
    if(props && props[c] != null && String(props[c]).trim() !== "") return String(props[c]).trim();
  }
  const keys = props ? Object.keys(props) : [];
  for(const cand of candidates){
    const k = keys.find(x => x.toLowerCase() === cand.toLowerCase());
    if(k && props[k] != null) return String(props[k]).trim();
  }
  return null;
}

// Very lightweight "centroid" from first ring average (lon/lat)
function approxCentroidLonLat(feature){
  try{
    const ring = feature.geometry.coordinates[0];
    let sx=0, sy=0, n=0;
    for(const pt of ring){
      sx += pt[0]; sy += pt[1]; n++;
    }
    return {lon: sx/n, lat: sy/n};
  } catch(e){
    return null;
  }
}

/* =========================================================
   Gesamtbereich: nur rechtsrheinisch, südlich Deutz
   (Envelope + rechtsrheinischer Filter per centroid lon)
   ========================================================= */
const env = {
  xmin: 6.975, ymin: 50.925,  // südlich: Deutz
  xmax: 7.055, ymax: 50.975   // nicht viel nördlicher als Mülheim
};

// "rechtsrheinisch" Filter: alles östlich einer groben Rhein-Linie (hier über Lon-Schwellwert)
const RIGHT_BANK_LON_MIN = 6.975;

// Layer refs
let stLayer=null, svLayer=null;

async function loadBoundaries(){
  setStatus("<b>Status:</b> Lade Stadtteile…");

  const qCommon = {
    where: "1=1",
    outFields: "*",
    returnGeometry: "true",
    outSR: "4326",
    inSR: "4326",
    geometry: `${env.xmin},${env.ymin},${env.xmax},${env.ymax}`,
    geometryType: "esriGeometryEnvelope",
    spatialRel: "esriSpatialRelIntersects",
    resultRecordCount: "5000"
  };

  const st = await arcgisQuery(3, qCommon); // Stadtteile
  setStatus("<b>Status:</b> Lade Stadtviertel…");
  const sv = await arcgisQuery(1, qCommon); // Stadtviertel

  // Filter auf rechtsrheinisch (über centroid)
  st.features = st.features.filter(f => {
    const c = approxCentroidLonLat(f);
    return c && c.lon >= RIGHT_BANK_LON_MIN;
  });
  sv.features = sv.features.filter(f => {
    const c = approxCentroidLonLat(f);
    return c && c.lon >= RIGHT_BANK_LON_MIN;
  });

  // Remove existing
  if(stLayer) map.removeLayer(stLayer);
  if(svLayer) map.removeLayer(svLayer);

  // Stadtteile (Kontext) – sehr transparent, damit Basemap sichtbar bleibt
  st.features.forEach(ft => {
    const nm = pickName(ft.properties, ["STADTTEIL","NAME","Name","stadtteil"]) || "Ort";
    ft.properties.__name = nm;
    ft.properties.__key  = "ST:" + nm;
    ft.properties.__kind = "ST";
  });

  stLayer = L.geoJSON(st, {
    style: (feature) => styleForKey(feature.properties.__key, "ST"),
    onEachFeature: (feature, layer) => {
      const key = feature.properties.__key;
      const name = feature.properties.__name;
      layer.__kind = "ST";
      layerByKey[key] = layer;
      layer.bindPopup(popupHTML(key, name), {maxWidth: 300});
      layer.on('click', () => layer.openPopup());
    }
  }).addTo(map);

  // Stadtviertel – deutlicher sichtbar; wichtig für "mehrere kleine Teile" in Mülheim, ohne es zu labeln
  sv.features.forEach(ft => {
    const nm = pickName(ft.properties, ["STADTVIERTEL","NAME","Name","stadtviertel","STV","BEZEICHNUNG"]) || "Ort";
    ft.properties.__name = nm;
    ft.properties.__key  = "SV:" + nm;
    ft.properties.__kind = "SV";
  });

  svLayer = L.geoJSON(sv, {
    style: (feature) => styleForKey(feature.properties.__key, "SV"),
    onEachFeature: (feature, layer) => {
      const key = feature.properties.__key;
      const name = feature.properties.__name;
      layer.__kind = "SV";
      layerByKey[key] = layer;
      layer.bindPopup(popupHTML(key, name), {maxWidth: 300});
      layer.on('click', () => layer.openPopup());
    }
  }).addTo(map);

  // Spezial-Standorte als eigene "Kacheln" (Punktpuffer) – Name pur
  addPOI("Lanxess Arena", [50.9386, 6.9822]);
  addPOI("Carlswerk",     [50.9546, 7.0149]);

  // Fit bounds nur rechtsrheinisch
  map.fitBounds(L.latLngBounds([[env.ymin, env.xmin],[env.ymax, env.xmax]]), {padding:[20,20]});

  setStatus("<b>Status:</b> Fertig. Tipp: Flächen antippen → Rolle wählen.");
}

// POI circle "tile"
function addPOI(name, latlng){
  const key = "POI:" + name;
  const circle = L.circle(latlng, styleForKey(key, "POI"));
  circle.__kind = "POI";
  layerByKey[key] = circle;
  circle.bindPopup(popupHTML(key, name), {maxWidth: 280});
  circle.on('click', () => circle.openPopup());
  circle.addTo(map);
}

// Tools
const tools = L.control({position:'topright'});
tools.onAdd = function() {
  const div = L.DomUtil.create('div', 'statusBox');
  div.style.minWidth = '180px';
  div.innerHTML = `
    <b>Tools</b><br>
    <button id="btnReload" style="width:100%; margin-top:6px; padding:8px 10px; border:1px solid #ddd; border-radius:10px; background:#fff; font-size:13px; cursor:pointer;">Grenzen neu laden</button>
    <button id="btnReset" style="width:100%; margin-top:6px; padding:8px 10px; border:1px solid #ddd; border-radius:10px; background:#fff; font-size:13px; cursor:pointer;">Farben zurücksetzen</button>
    <button id="btnExport" style="width:100%; margin-top:6px; padding:8px 10px; border:1px solid #ddd; border-radius:10px; background:#fff; font-size:13px; cursor:pointer;">Export (Text)</button>
  `;
  L.DomEvent.disableClickPropagation(div);
  return div;
};
tools.addTo(map);

function resetColors(){
  saved = {}; save();
  Object.keys(layerByKey).forEach(key => {
    const lyr = layerByKey[key];
    if(lyr.setStyle) lyr.setStyle(styleForKey(key, lyr.__kind || "ST"));
  });
}
function exportText(){
  const keys = Object.keys(layerByKey).sort();
  const out = keys.map(k => ({gebiet: k.replace(/^ST:/,"").replace(/^SV:/,"").replace(/^POI:/,""), rolle: saved[k] || ""}));
  prompt("Kopiere den Export-Text (Copy):", JSON.stringify(out, null, 2));
}

document.addEventListener('click', (e) => {
  if(e.target && e.target.id === 'btnReload') loadBoundaries().catch(err => setStatus("<b>Status:</b> Fehler: " + err.message));
  if(e.target && e.target.id === 'btnReset') resetColors();
  if(e.target && e.target.id === 'btnExport') exportText();
});

loadBoundaries().catch(err => {
  console.error(err);
  setStatus("<b>Status:</b> Fehler beim Laden der Grenzen.<br><span style='color:#b00'>"+ err.message +"</span>");
});
</script>
</body>
</html>
