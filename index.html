<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Strukturwandel Köln – Deutz & Mülheim (reale Grenzen, Zoom-Details, eigene Rechtecke)</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
<style>
  html, body { height:100%; margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
  body { display:flex; flex-direction:column; }
  header { padding:10px 12px; border-bottom:1px solid #ddd; background:#fff; flex:0 0 auto; }
  header h1 { font-size:16px; margin:0 0 6px; }
  header p { margin:0; font-size:12px; color:#444; line-height:1.25; }
  #map { flex:1 1 auto; width:100%; min-height: 320px; }

  /* SW + deutlich (Straßen/Schrift erkennbar) */
  .leaflet-tile { filter: grayscale(100%) contrast(220%) brightness(92%); }

  .roleBtn{
    display:block; width:100%;
    margin:6px 0; padding:10px 12px;
    font-size:14px; border-radius:10px;
    border:1px solid #ddd; background:#f7f7f7;
  }
  .roleBtn:active { transform: translateY(1px); }
  .dangerBtn{ background:#fff0f0; border-color:#f3b2b2; }

  .statusBox{
    background: rgba(255,255,255,.95);
    border: 1px solid #ddd;
    border-radius: 12px;
    padding: 8px 10px;
    box-shadow: 0 10px 26px rgba(0,0,0,.12);
    font-size: 12px;
    line-height: 1.25;
  }

  .districtLabel{
    background: rgba(255,255,255,0.82);
    border: 1px solid rgba(0,0,0,0.22);
    border-radius: 999px;
    padding: 2px 8px;
    color:#111;
    font-weight: 900;
    font-size: 12px;
    box-shadow: 0 6px 18px rgba(0,0,0,.14);
    white-space: nowrap;
  }
  .poiLabel{
    background: rgba(255,255,255,0.90);
    border: 1px solid rgba(0,0,0,0.28);
    border-radius: 10px;
    padding: 2px 6px;
    color:#111;
    font-weight: 900;
    font-size: 11px;
    box-shadow: 0 6px 18px rgba(0,0,0,.14);
    white-space: nowrap;
  }
</style>
</head>
<body>
<header>
  <h1>Strukturwandel Köln – Rollenkarte (Deutz & Mülheim)</h1>
  <p>
    Klick auf eine Fläche → Funktion/Rolle des Raums wählen. Zoom ≥16: Schanzenstraße wird kleinteiliger (Teilflächen passen sich an die Bezirksgrenzen an).
    <br><b>Feld hinzufügen:</b> Button unten links → Ecke 1 tippen → Ecke 2 tippen → Rechteck anlegen (färbbar & löschbar).
  </p>
</header>

<div id="map" aria-label="Interaktive Karte"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
/* ========= Safety: sichtbare Fehlermeldung statt "weiß" ========= */
window.addEventListener('error', (e) => {
  try {
    const msg = (e && e.message) ? e.message : 'Unbekannter Fehler';
    const box = document.querySelector('.statusBox');
    if(box) box.innerHTML = "<b>Status:</b> JS-Fehler: <span style='color:#b00'>" + msg + "</span>";
  } catch(_) {}
});

const map = L.map('map', { zoomControl: true }).setView([50.948, 7.008], 13);
setTimeout(() => { try { map.invalidateSize(); } catch(e){} }, 60);

/* Panes (Z-Order steuert Überlagerung) */
map.createPane('paneST');      map.getPane('paneST').style.zIndex = 350;
map.createPane('paneSV');      map.getPane('paneSV').style.zIndex = 360;
map.createPane('paneMICRO');   map.getPane('paneMICRO').style.zIndex = 370;
map.createPane('paneUSER');    map.getPane('paneUSER').style.zIndex = 410;
map.createPane('panePOI');     map.getPane('panePOI').style.zIndex = 420;

/* Basemap (OSM) – SW/High-Contrast via CSS */
const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 19, attribution: '© OpenStreetMap-Mitwirkende'
}).addTo(map);

const carto = L.tileLayer('https://cartodb-basemaps-{s}.global.ssl.fastly.net/light_all/{z}/{x}/{y}.png', {
  subdomains:'abcd', maxZoom: 20,
  attribution: 'Map tiles by Carto (CC BY 3.0). Data © OpenStreetMap contributors (ODbL).'
});
L.control.layers({"OSM Straßen (SW Hi-Contrast)": osm, "Carto Light (SW)": carto}, null, {collapsed:true}).addTo(map);

/* Rollen / Farben (inkl. pink + hellgrün) */
const roleColors = {
  "Industrie": "blue",
  "Start-ups": "yellow",
  "Wohnen": "red",
  "Freizeit/Kultur": "lightgreen",
  "Einzelhandel/Gewerbe": "hotpink"
};


const EXCLUDED_OFFICIAL = [
  "holweide-west",
  "kleinherl",
  "buchheim",
  "böcking-siedlung",
  "boecking-siedlung",
  "böcking",
  "boecking",
  "mülheim-nord",
  "muelheim-nord",
  "germaniastraße",
  "germaniastrasse"
];

function isExcludedOfficial(name){
  const n = (name || "").toLowerCase();
  return EXCLUDED_OFFICIAL.some(x => n.includes(x));
}

function purgeExcludedFromStorage(){
  try{
    Object.keys(saved || {}).forEach(k => {
      const nm = k.replace(/^SV:/,"").replace(/^ST:/,"").replace(/^POI:/,"").replace(/^MICRO:/,"");
      if(isExcludedOfficial(nm)) delete saved[k];
    });
    saveRoles();
  } catch(e){}
}


const STORAGE_KEY = "koeln_roles_deutz_muelheim_v10";
const USER_RECTS_KEY = "koeln_user_rects_v2";

let saved = {};
try { saved = JSON.parse(localStorage.getItem(STORAGE_KEY) || "{}"); } catch(e) { saved = {}; }
function saveRoles(){ localStorage.setItem(STORAGE_KEY, JSON.stringify(saved)); }

purgeExcludedFromStorage();

let userRects = [];
try { userRects = JSON.parse(localStorage.getItem(USER_RECTS_KEY) || "[]"); } catch(e) { userRects = []; }
function saveUserRects(){ localStorage.setItem(USER_RECTS_KEY, JSON.stringify(userRects)); }

function popupHTML(key, name, allowDelete=false){
  return `
    <b>${name}</b><br>
    <button class="roleBtn" onclick="setRole('${key}','Industrie')">Produktion & Logistik</button>
    <button class="roleBtn" onclick="setRole('${key}','Start-ups')">Innovation- und Kreativwirtschaft</button>
    <button class="roleBtn" onclick="setRole('${key}','Einzelhandel/Gewerbe')">Einzelhandel & Dienstleistungen</button>
    <button class="roleBtn" onclick="setRole('${key}','Wohnen')">Wohnen & soziale Infrastruktur</button>
    <button class="roleBtn" onclick="setRole('${key}','Freizeit/Kultur')">Freizeit, Kultur & Mobilität</button>
    <button class="roleBtn" onclick="clearRole('${key}')">Keine Zuordnung</button>
    ${allowDelete ? `<button class="roleBtn dangerBtn" onclick="deleteUserRect('${key}')">Rechteck löschen</button>` : ``}
  `;
}

const layerByKey = {};
const microGroup = L.layerGroup([], {pane:'paneMICRO'}).addTo(map);
const userGroup  = L.layerGroup([], {pane:'paneUSER'}).addTo(map);

window.setRole = function(key, role){
  if(drawMode) return; // im Rechteckmodus nichts anderes markieren
  saved[key] = role; saveRoles();
  const lyr = layerByKey[key];
  if(lyr && lyr.setStyle) lyr.setStyle(styleForKey(key, lyr.__kind));
  if(lyr) lyr.closePopup();
};
window.clearRole = function(key){
  if(drawMode) return;
  delete saved[key]; saveRoles();
  const lyr = layerByKey[key];
  if(lyr && lyr.setStyle) lyr.setStyle(styleForKey(key, lyr.__kind));
  if(lyr) lyr.closePopup();
};

function styleForKey(key, kind){
  const role = saved[key];
  const fillColor = (role && roleColors[role]) ? roleColors[role] : "white";
  const hasRole = !!(role && roleColors[role]);

  if(kind === "POI"){
    return { pane:'panePOI', color:"#111", weight: 5, fillColor, fillOpacity: hasRole ? 1.0 : 0.20 };
  }
  if(kind === "USER"){
    return { pane:'paneUSER', color:"#111", weight: 4, fillColor, fillOpacity: hasRole ? 1.0 : 0.12 };
  }
  const baseOpacity = (kind === "SV") ? 0.14 : 0.10;
  return { color:"#111", weight: 3, fillColor, fillOpacity: hasRole ? 0.55 : baseOpacity };
}

/* Status */
const statusCtl = L.control({position:'topleft'});
let statusEl;
statusCtl.onAdd = function(){
  statusEl = L.DomUtil.create('div', 'statusBox');
  statusEl.innerHTML = "<b>Status:</b> Lade Grenzen…";
  L.DomEvent.disableClickPropagation(statusEl);
  return statusEl;
};
statusCtl.addTo(map);
function setStatus(html){ if(statusEl) statusEl.innerHTML = html; }

/* ArcGIS fetch */
async function arcgisQuery(layerId, params){
  const base = `https://geoportal.stadt-koeln.de/arcgis/rest/services/Basiskarten/kgg/MapServer/${layerId}/query`;
  const p = new URLSearchParams(params);

  // try geojson
  let url = base + "?" + p.toString() + "&f=geojson";
  try{
    const r = await fetch(url);
    if(r.ok){
      const gj = await r.json();
      if(gj && gj.type === "FeatureCollection") return gj;
    }
  } catch(e){}

  // fallback pjson
  url = base + "?" + p.toString() + "&f=pjson";
  const r2 = await fetch(url);
  if(!r2.ok) throw new Error("ArcGIS query failed: " + r2.status);
  const data = await r2.json();
  return esriToGeoJSON(data);
}

function esriToGeoJSON(esri){
  const feats = (esri.features || []).map((f) => {
    const props = f.attributes || {};
    const g = f.geometry || {};
    if(g.rings){
      return {
        type:"Feature",
        properties: props,
        geometry: { type:"Polygon", coordinates: g.rings.map(r => r.map(pt => [pt[0], pt[1]])) }
      };
    }
    return null;
  }).filter(Boolean);
  return { type:"FeatureCollection", features: feats };
}

function pickName(props, candidates){
  for(const c of candidates){
    if(props && props[c] != null && String(props[c]).trim() !== "") return String(props[c]).trim();
  }
  const keys = props ? Object.keys(props) : [];
  for(const cand of candidates){
    const k = keys.find(x => x.toLowerCase() === cand.toLowerCase());
    if(k && props[k] != null) return String(props[k]).trim();
  }
  return null;
}

function approxCentroidLonLat(feature){
  try{
    const ring = feature.geometry.coordinates[0];
    let sx=0, sy=0, n=0;
    for(const pt of ring){ sx += pt[0]; sy += pt[1]; n++; }
    return {lon: sx/n, lat: sy/n};
  } catch(e){ return null; }
}

/* Polygon clipping (Sutherland–Hodgman) */
function clipPolyToRect(subject, rect){
  function inside(p, edge){
    const x=p[0], y=p[1];
    if(edge==='left') return x >= rect.minX;
    if(edge==='right') return x <= rect.maxX;
    if(edge==='bottom') return y >= rect.minY;
    if(edge==='top') return y <= rect.maxY;
    return true;
  }
  function intersect(s, e, edge){
    const x1=s[0], y1=s[1], x2=e[0], y2=e[1];
    if(edge==='left' || edge==='right'){
      const x = (edge==='left') ? rect.minX : rect.maxX;
      const t = (x2-x1===0) ? 0 : (x - x1)/(x2 - x1);
      return [x, y1 + t*(y2-y1)];
    } else {
      const y = (edge==='bottom') ? rect.minY : rect.maxY;
      const t = (y2-y1===0) ? 0 : (y - y1)/(y2 - y1);
      return [x1 + t*(x2-x1), y];
    }
  }
  let output = subject.slice();
  const edges = ['left','right','bottom','top'];
  for(const edge of edges){
    const input = output.slice();
    output = [];
    if(input.length === 0) break;
    let S = input[input.length-1];
    for(const E of input){
      if(inside(E, edge)){
        if(inside(S, edge)){
          output.push(E);
        } else {
          output.push(intersect(S,E,edge));
          output.push(E);
        }
      } else {
        if(inside(S, edge)){
          output.push(intersect(S,E,edge));
        }
      }
      S = E;
    }
  }
  const cleaned = [];
  for(const p of output){
    if(cleaned.length===0) cleaned.push(p);
    else {
      const q = cleaned[cleaned.length-1];
      if(Math.abs(p[0]-q[0])>1e-10 || Math.abs(p[1]-q[1])>1e-10) cleaned.push(p);
    }
  }
  return cleaned.length>=3 ? cleaned : [];
}

/* ROUTE envelope */
const env = { xmin: 6.975, ymin: 50.932, xmax: 7.035, ymax: 50.972 };
const RIGHT_BANK_LON_MIN = 6.975;

let stLayer=null, svLayer=null;
let schanzenTargets = []; // {name, ring}

function addPermanentLabel(layer, name, className){
  layer.bindTooltip(name, { permanent:true, direction:'center', className, opacity:1.0 });
}

async function loadBoundaries(){
  purgeExcludedFromStorage();
  setStatus("<b>Status:</b> Lade Deutz & Mülheim…");

  const qCommon = {
    where: "1=1",
    outFields: "*",
    returnGeometry: "true",
    outSR: "4326",
    inSR: "4326",
    geometry: `${env.xmin},${env.ymin},${env.xmax},${env.ymax}`,
    geometryType: "esriGeometryEnvelope",
    spatialRel: "esriSpatialRelIntersects",
    resultRecordCount: "5000"
  };

  const st = await arcgisQuery(3, qCommon);
  const sv = await arcgisQuery(1, qCommon);

  st.features = st.features.filter(f => {
    const c = approxCentroidLonLat(f);
    if(!(c && c.lon >= RIGHT_BANK_LON_MIN)) return false;
    const nm = (pickName(f.properties, ["STADTTEIL","NAME","Name","stadtteil"]) || "").trim();
    if(isExcludedOfficial(nm)) return false;
    if(/^Siedlung/i.test(nm)) return false;
    return /deutz/i.test(nm) || /mülheim/i.test(nm) || /muelheim/i.test(nm);
  });

  sv.features = sv.features.filter(f => {
    const c = approxCentroidLonLat(f);
    if(!(c && c.lon >= RIGHT_BANK_LON_MIN)) return false;
    const nm = (pickName(f.properties, ["STADTVIERTEL","NAME","Name","stadtviertel","STV","BEZEICHNUNG"]) || "").trim();
    if(isExcludedOfficial(nm)) return false;
    
    const lname = nm.toLowerCase();
    if(
      lname.includes("holweide-west") ||
      lname.includes("kleinherl") ||
      lname.includes("buchheim") ||
      lname.includes("böcking") || lname.includes("boecking") ||
      lname.includes("mülheim-nord") || lname.includes("muelheim-nord")
    ) return false;
if(/^Siedlung/i.test(nm)) return false;

    const stnm = (pickName(f.properties, ["STADTTEIL","STADTTEILNAME","stadtteil"]) || "").trim();
    const bznm = (pickName(f.properties, ["STADTBEZIRK","BEZIRK","stadtbezirk"]) || "").trim();
    const tag = (nm + " " + stnm + " " + bznm).toLowerCase();
    return tag.includes("mülheim") || tag.includes("muelheim");
  });

  schanzenTargets = [];
  microGroup.clearLayers();

  if(stLayer) map.removeLayer(stLayer);
  if(svLayer) map.removeLayer(svLayer);

  st.features.forEach(ft => {
    const nm = (pickName(ft.properties, ["STADTTEIL","NAME","Name","stadtteil"]) || "Ort").trim();
    ft.properties.__name = nm;
    ft.properties.__key  = "ST:" + nm;
    ft.properties.__kind = "ST";
  });

  stLayer = L.geoJSON(st, {
    pane:'paneST',
    style: (feature) => styleForKey(feature.properties.__key, "ST"),
    onEachFeature: (feature, layer) => {
      const key = feature.properties.__key;
      const name = feature.properties.__name;
      layer.__kind = "ST";
      layerByKey[key] = layer;
      layer.bindPopup(popupHTML(key, name), {maxWidth: 340});
      layer.on('click', () => { if(!drawMode) layer.openPopup(); });
      addPermanentLabel(layer, name, "districtLabel");
    }
  }).addTo(map);

  sv.features.forEach(ft => {
    const nm = (pickName(ft.properties, ["STADTVIERTEL","NAME","Name","stadtviertel","STV","BEZEICHNUNG"]) || "Ort").trim();
    ft.properties.__name = nm;
    ft.properties.__key  = "SV:" + nm;
    ft.properties.__kind = "SV";

    if(/schanzenstr/i.test(nm) || /GE\s*schanzen/i.test(nm)){
      const ring = ft.geometry.coordinates[0];
      schanzenTargets.push({name: nm, ring});
    }
  });

  svLayer = L.geoJSON(sv, {
    pane:'paneSV',
    style: (feature) => styleForKey(feature.properties.__key, "SV"),
    onEachFeature: (feature, layer) => {
      const key = feature.properties.__key;
      const name = feature.properties.__name;
      layer.__kind = "SV";
      layerByKey[key] = layer;
      layer.bindPopup(popupHTML(key, name), {maxWidth: 340});
      layer.on('click', () => { if(!drawMode) layer.openPopup(); });
      addPermanentLabel(layer, name, "districtLabel");
    }
  }).addTo(map);

  addPOI("Lanxess Arena", [50.938338, 6.982951], 180);
  addPOI("koelnmesse",    [50.944600, 6.981800], 230);
  addPOI("Bhf Deutz",     [50.940830, 6.975000], 190);
  addPOI("Carlswerk",     [50.966074, 7.015056], 190);

  renderUserRects();

  map.fitBounds(L.latLngBounds([[env.ymin, env.xmin],[env.ymax, env.xmax]]), {padding:[30,30]});
  setStatus("<b>Status:</b> Fertig. Zoom ≥16: Schanzenstraße wird kleinteiliger. Unten links: Feld hinzufügen.");
  updateMicroTiles();
}

function addPOI(name, latlng, radius){
  const key = "POI:" + name;
  const circle = L.circle(latlng, { pane:'panePOI', radius, ...styleForKey(key, "POI") });
  circle.__kind = "POI";
  layerByKey[key] = circle;
  circle.bindPopup(popupHTML(key, name), {maxWidth: 320});
  circle.on('click', () => { if(!drawMode) circle.openPopup(); });
  circle.addTo(map);
  circle.bindTooltip(name, { permanent:true, direction:'top', offset:[0,-8], className:'poiLabel', opacity:1.0 });
}

/* Zoom-abhängige Teilflächen (Schanzenstraße) – CLIPPED */
function updateMicroTiles(){
  microGroup.clearLayers();
  const z = map.getZoom();
  if(z < 16) return;

  schanzenTargets.forEach(target => {
    const name = target.name;
    const ring = target.ring;

    let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
    ring.forEach(([x,y]) => { minX=Math.min(minX,x); minY=Math.min(minY,y); maxX=Math.max(maxX,x); maxY=Math.max(maxY,y); });

    const nx = (z >= 17) ? 6 : 5;
    const ny = (z >= 17) ? 5 : 4;
    const dx = (maxX-minX)/nx;
    const dy = (maxY-minY)/ny;

    for(let ix=0; ix<nx; ix++){
      for(let iy=0; iy<ny; iy++){
        const rect = { minX: minX + ix*dx, maxX: minX + (ix+1)*dx, minY: minY + iy*dy, maxY: minY + (iy+1)*dy };
        const clipped = clipPolyToRect(ring, rect);
        if(clipped.length < 3) continue;

        const microName = `${name} – Teil ${ix+1}.${iy+1}`;
        const microKey  = `MICRO:${name}:${ix+1}.${iy+1}`;

        const poly = L.polygon(clipped.map(([lon,lat]) => [lat,lon]), {
          pane:'paneMICRO',
          ...styleForKey(microKey, "SV"),
          weight: 2
        });
        poly.__kind = "SV";
        layerByKey[microKey] = poly;
        poly.bindPopup(popupHTML(microKey, microName), {maxWidth: 340});
        poly.on('click', () => { if(!drawMode) poly.openPopup(); });
        microGroup.addLayer(poly);
      }
    }
  });
}

/* ========= USER-RECHTECKE ========= */
let drawMode = false;
let firstCorner = null;
let previewRect = null;

function updateAddRectButton(){
  const btn = document.getElementById('btnAddRect');
  if(!btn) return;
  if(drawMode){
    btn.style.background = '#ffe9a8';
    btn.style.borderColor = '#e0b800';
    btn.style.fontWeight = '900';
    btn.textContent = '✓ Rechteckmodus';
  } else {
    btn.style.background = '#fff';
    btn.style.borderColor = '#ddd';
    btn.style.fontWeight = '700';
    btn.textContent = '+ Rechteck';
  }
}

/* Während drawMode: keine anderen Felder anklickbar, damit Klicks immer als Ecken zählen */
function setOtherLayersPointerEvents(enabled){
  Object.keys(layerByKey).forEach(key => {
    const lyr = layerByKey[key];
    if(lyr && lyr._path){
      lyr._path.style.pointerEvents = enabled ? 'auto' : 'none';
    }
  });
}

function setDrawMode(on){
  drawMode = on;
  firstCorner = null;
  if(previewRect){ map.removeLayer(previewRect); previewRect=null; }

  setOtherLayersPointerEvents(!on);

  if(on) setStatus("<b>Status:</b> Rechteckmodus aktiv. Tippe Ecke 1, dann Ecke 2. (Zum Beenden erneut klicken)");
  else setStatus("<b>Status:</b> Fertig. Unten links: Feld hinzufügen.");
  updateAddRectButton();
}

function keyForUserRect(id){ return "USER:" + id; }

function addUserRect(bounds){
  const id = Date.now().toString(36) + Math.random().toString(36).slice(2,7);
  userRects.push({id, bounds});
  saveUserRects();
  renderUserRects();
}

window.deleteUserRect = function(key){
  const id = key.replace(/^USER:/,'');
  userRects = userRects.filter(r => r.id !== id);
  saveUserRects();
  delete saved[key];
  saveRoles();
  renderUserRects();
};

function renderUserRects(){
  userGroup.clearLayers();
  userRects.forEach(r => {
    const key = keyForUserRect(r.id);
    const rect = L.rectangle(r.bounds, { pane:'paneUSER', ...styleForKey(key, "USER") });
    rect.__kind = "USER";
    layerByKey[key] = rect;
    rect.bindPopup(popupHTML(key, "Eigenes Rechteck", true), {maxWidth: 340});
    rect.on('click', () => { if(!drawMode) rect.openPopup(); });
    userGroup.addLayer(rect);

    const center = rect.getBounds().getCenter();
    const plus = L.marker(center, {
      pane:'paneUSER',
      interactive: false,
      icon: L.divIcon({className:'', html:`<div style="font-weight:900;font-size:18px;line-height:18px;color:#111;text-shadow:0 2px 6px rgba(0,0,0,.25);">+</div>`})
    });
    userGroup.addLayer(plus);
  });

  // falls drawMode aktiv ist, nach Neurendern wieder deaktivieren
  setOtherLayersPointerEvents(!drawMode);
}

/* Map click handler for draw mode */
map.on('click', (e) => {
  if(!drawMode) return;

  if(!firstCorner){
    firstCorner = e.latlng;
    setStatus("<b>Status:</b> Ecke 1 gesetzt. Tippe Ecke 2.");
    previewRect = L.rectangle([firstCorner, firstCorner], {pane:'paneUSER', color:'#111', weight:2, fill:false}).addTo(map);
  } else {
    const second = e.latlng;
    const bounds = L.latLngBounds(firstCorner, second);
    if(previewRect){ map.removeLayer(previewRect); previewRect=null; }
    addUserRect([[bounds.getSouthWest().lat, bounds.getSouthWest().lng],[bounds.getNorthEast().lat, bounds.getNorthEast().lng]]);
    setDrawMode(false); // automatisch beenden
  }
});

map.on('mousemove', (e) => {
  if(!drawMode || !firstCorner || !previewRect) return;
  previewRect.setBounds(L.latLngBounds(firstCorner, e.latlng));
});

/* Tools: nur "Feld hinzufügen" unten links, etwas höher */
const tools = L.control({position:'bottomleft'});
tools.onAdd = function() {
  const div = L.DomUtil.create('div', 'statusBox');
  div.style.minWidth = '140px';
  div.style.marginBottom = '70px';
  div.innerHTML = `
    <b>Feld hinzufügen</b><br>
    <button id="btnAddRect" style="width:100%; margin-top:6px; padding:6px 8px; border:1px solid #ddd; border-radius:8px; background:#fff; font-size:12px; cursor:pointer;">+ Rechteck</button>
  `;
  L.DomEvent.disableClickPropagation(div);
  return div;
};
tools.addTo(map);

document.addEventListener('click', (e) => {
  if(e.target && e.target.id === 'btnAddRect') setDrawMode(!drawMode);
});

map.on('zoomend', updateMicroTiles);

updateAddRectButton();
loadBoundaries().catch(err => {
  console.error(err);
  setStatus("<b>Status:</b> Fehler beim Laden der Grenzen.<br><span style='color:#b00'>"+ err.message +"</span>");
});
</script>
</body>
</html>
